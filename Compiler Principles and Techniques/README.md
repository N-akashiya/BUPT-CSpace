# 关于编译原理

> 不喜欢这种感觉赢不了机器的课

- 教材：对于至少我们专业的编译原理考试来说，明显还是目前使用的更有针对性。我觉得概念讲述的顺序怪怪的，总是还用不到的时候抛出概念，等用到的时候忘了又要重看，但这个问题好像无解，不得不反复看。
- 最不会写报告的人这回Lab得分还不错，大概是因为助教有好好看
- Some weird thoughts
    
    有一种 *“抄代码被抓，是编译没学好”* 的说法，对此我以OJ为例探究了一下。
    OJ会首先将代码提交进行编译。编译过程确保代码没有语法错误，且符合语言规范。如果编译失败，代码会被判定为编译错误，无法进一步执行。编译成功的代码会被执行，OJ通常会给定测试用例，系统会执行代码，并将代码的输出与预期输出进行对比，来判断代码是否正确。
    **OJ和编译相关的一些错误**
    - Memory Limit Exceeded: 编译器通常会自动为栈分配一定的内存空间。如果程序使用了过深的递归或者过大的局部变量，栈可能会溢出; 
    - Compile Error: 词法分析、语法分析、语义分析任何一个环节错误，或是类型检查时不匹配; 
    - Time Limit Exceeded: 编译器优化可能在一定程度上改善程序的执行效率，但算法本身的选择才是最关键的因素。
	
    **OJ使用的一些代码查重技术**
    - 文本匹配，最基础直接的方法；
    - 抽象语法树（AST）比较，编译器在解析代码时会将源代码转换成抽象语法树，表示代码的结构和逻辑。不同的代码写法可能会生成相同的抽象语法树，因此基于AST的比较可以检测到不同写法下的相似代码；
    - 指纹算法通过计算代码的“指纹”来进行相似性检测，可以有效地识别经过重构的代码，即使在变量名、注释等部分不同的情况下，也能发现代码逻辑上的相似性。
    
    OJ的查重机制不仅仅关注代码的文本内容，还会考虑代码结构、逻辑甚至是语法层面的差异。所以说，学好编译原理，理解了代码的优化和重构方法，也许就能编写出既高效又具有一定独特性的代码，更有可能通过查重检测。声明：这不是在提倡抄袭代码。
